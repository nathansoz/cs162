#include "Board.h"

/*
    The Cord class is a nice wrapper around points. I'm just using it to
    have a nice way to make a vector that can be passed to a function and
    populate the board with a given pattern
 */
Cord::Cord(int heightFromTop, int widthFromleft)
{
    x = heightFromTop;
    y = widthFromleft;
}

Board::Board() {};

/*
    The Board constructor allows the user of the API to construct a board of
    arbitrary size. I've hard coded those sizes in to meet the assignment requirements
    but this class could be used in any implementation of the GOL and meet whatever requirments
    that programmer has
 */
Board::Board(int height, int width)
{

    boardHeight = height + (MARGIN * 2);
    boardWidth = width + (MARGIN * 2);


    boardInit = false;
    GenerateEmptyBoard();
    boardInit = true;
}

/*
    If an instance of the board class is ever on the heap, we want a way to clear up
    the memory that we had been using. This prevents memory leaks. hurray!
 */
Board::~Board()
{
    if(boardInit)
    {
        for (int i = 0; i < boardHeight; i++)
        {
            delete[] boardWorld[i];
        }

        delete[] boardWorld;
    }
}

/*
    Starts from the margin and ends before the opposite margin. . == dead cell and X == live cell
    A frame counter is also provided for the user's convenience
 */
void Board::PrintBoard()
{
    std::cout << "Frame: " << frame << std::endl;
    for(int i = MARGIN; i < boardHeight - MARGIN; i++)
    {
        for(int j = MARGIN; j  < boardWidth - MARGIN; j++)
        {
            if(boardWorld[i][j].GetState() == CellState::FILLED)
            {
                std::cout << "X" << " ";
            }
            else
            {
                std::cout << "." << " ";
            }
        }

        std::cout << std::endl;
    }

}

int Board::SumNeighborCells(int height, int width)
{
    int fillTotal = 0;

    for(int i = (height - 1); i <= (height + 1); i++)
    {
        for(int j = (width -1); j <= (width + 1); j++)
        {
            //Capture edge cases, corner cases, and the cell that we are targeting. We don't want to include
            //these in our total of alive cells.
            if(i < 0 || i >= boardHeight || j < 0 || j >= boardWidth || (i == height && j == width))
                continue;
            //anything else is fair game. let's add it to our alivecell total if they are filled.
            else
            {
                if(boardWorld[i][j].GetState() == CellState::FILLED)
                {
                    fillTotal++;
                }
            }
        }

    }

    return fillTotal;
}

/*
    Each frame of the board is generated by this function. We loop through the cells,
    get the sum of their neighbors, and set their NEXT state. I did this so that we
    don't have an issue where a cell changes and then doesn't get counted by cells next to it.

    After we have set the NEXT state of every cell, it is safe to iterate through the list again
    and set the actual state of every cell. This doesn't display anything. We will need to call
    PrintBoard() in order to see the result of Tick().
 */
void Board::Tick()
{
    std::cout << std::endl;
    for(int i = 0; i < boardHeight; i++)
    {
        for(int j = 0; j < boardWidth; j++)
        {
            int nearCells = SumNeighborCells(i, j);
            if(boardWorld[i][j].GetState() == CellState::EMPTY)
            {
                if(nearCells == 3)
                {
                    boardWorld[i][j].SetNextState(CellState::FILLED);
                }
                else
                {
                    boardWorld[i][j].SetNextState(CellState::EMPTY);
                }
            }
            else
            {
                if(nearCells <= 1)
                {
                    boardWorld[i][j].SetNextState(CellState::EMPTY);
                }
                else if(nearCells > 3)
                {
                    boardWorld[i][j].SetNextState(CellState::EMPTY);
                }
            }

        }
    }
    for(int i = 0; i < boardHeight; i++)
    {
        for(int j = 0; j < boardWidth; j++)
        {
            boardWorld[i][j].Increment();
        }
    }

    frame++;
}

/*
    If there is already a board, this function frees the memory used by the previous board and
    allocates new memory for a new board. This prevents memory leaks.

    This function, incidentally, also sets everything to empty.
 */
void Board::GenerateEmptyBoard()
{

    if(boardInit)
    {
        for (int i = 0; i < boardHeight; i++)
        {
            delete[] boardWorld[i];
        }

        delete[] boardWorld;
    }

    boardWorld = new Cell* [boardHeight];
    for(int i = 0; i < boardHeight; i++)
    {
        boardWorld[i] = new Cell[boardWidth];
    }

    for(int i = 0; i < boardHeight; i++)
    {
        for(int j = 0; j < boardWidth; j++)
        {

            boardWorld[i][j].SetNextState(CellState::EMPTY);
            boardWorld[i][j].Increment();
        }
    }

    frame = 0;
}

/*
    This little helper function allows us to define a standard way to provide
    a set of Co-ordinates and fill them in on the board. It adjusts for margin
    and from any user defined location.
 */
void Board::PopulateBoard(std::vector<Cord> const & cords, int fromTop, int fromleft)
{
    for(int i = 0; i < cords.size(); i++)
    {
        int x = cords[i].x + MARGIN + fromTop;
        int y = cords[i].y + MARGIN + fromleft;

        boardWorld[x][y].SetNextState(CellState::FILLED);
        boardWorld[x][y].Increment();
    }
}

/*
    These functions all simply create a defined pattern set and fill them in on the board.
 */

void Board::SetBlinkerBoard(int fromTop, int fromLeft)
{

    GenerateEmptyBoard();

    const std::vector<Cord> blinker {Cord(0, 0), Cord(0, 1), Cord(0, 2)};

    PopulateBoard(blinker, fromTop, fromLeft);

}

void Board::SetGlider(int fromTopEdge, int fromLeftEdge)
{
    GenerateEmptyBoard();
    
    const std::vector<Cord> glider {Cord(0, 1), Cord(1, 2), Cord(2, 0), Cord(2, 1), Cord(2, 2)};

    PopulateBoard(glider, fromTopEdge, fromLeftEdge);
}

void Board::SetGliderGun(int fromTopEdge, int fromLeftEdge)
{
    GenerateEmptyBoard();

    const std::vector<Cord> glider {Cord(0,24), Cord(1,22), Cord(1,24), Cord(2,12), Cord(2,13),Cord(2,20),Cord(2,21),
                              Cord(2,34),Cord(2,35),Cord(3,11),Cord(3,15),Cord(3,20),Cord(3,21),Cord(3,34), Cord(3,35),
                              Cord(4,0),Cord(4,1),Cord(4,10),Cord(4,16),Cord(4,20),Cord(4,21),Cord(5,0),Cord(5,1),
                              Cord(5,10),Cord(5,14),Cord(5,16),Cord(5,17),Cord(5,22),Cord(5,24),Cord(6,10),Cord(6,16),
                              Cord(6,24),Cord(7,11),Cord(7,15),Cord(8,12),Cord(8,13)};

    PopulateBoard(glider, fromTopEdge, fromLeftEdge);
}




